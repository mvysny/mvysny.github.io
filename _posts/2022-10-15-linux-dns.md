---
layout: post
title: Linux DNS stopped working
---

The newest Linux/Ubuntu 22.04+ DNS resolve stack is a fucking spaghetti of resolvconf, systemd-resolved, Network Manager
and 34724 other cryptic shit. In the good old days you would add `nameserver` to `/etc/resolv.conf` and be
done with it. Now you can't even edit the file since it's a symlink to `../run/resolvconf/resolv.conf` with `nameserver 127.0.0.53`
which is a DNS server running locally on your machine by systemd-resolved.

If you see something like this, read on:

```bash
$ host -v www.google.com
Trying "www.google.com"
;; connection timed out; no servers could be reached
$ host -v www.google.com 127.0.0.53
Trying "www.google.com"
;; connection timed out; no servers could be reached
$ host -v www.google.com 8.8.8.8
Trying "www.google.com"
;; now works
```

## systemd-resolved

systemd-resolved now handles DNS resolution. It exposes a DNS server on `127.0.0.53:53`; `/etc/resolv.conf` then
contains `nameserver 127.0.0.53` which tells all Linux commands to resolve DNS via systemd-resolved.

To learn of the systemd-resolved DNS routing scheme, type in the following:

```bash
$ resolvectl status
Global
       Protocols: -LLMNR -mDNS -DNSOverTLS DNSSEC=no/unsupported
resolv.conf mode: stub

Link 2 (enp2s0f0)
Current Scopes: none
     Protocols: -DefaultRoute +LLMNR -mDNS -DNSOverTLS DNSSEC=no/unsupported

Link 5 (wlp3s0)
    Current Scopes: DNS
         Protocols: +DefaultRoute +LLMNR -mDNS -DNSOverTLS DNSSEC=no/unsupported
Current DNS Server: 192.168.0.1
       DNS Servers: 192.168.0.1

Link 6 (virbr0)
Current Scopes: none
     Protocols: -DefaultRoute +LLMNR -mDNS -DNSOverTLS DNSSEC=no/unsupported

Link 7 (docker0)
Current Scopes: none
```

You can view its logs and/or status, maybe they will reveal something of interest:

```bash
$ journalctl -u systemd-resolved.service
$ systemctl status systemd-resolved.service
```

Alternatively, simply restart the service:
```bash
$ sudo systemctl restart systemd-resolved.service
$ resolvectl status
```

## Troubleshooting

Print DNS servers for all links via `resolvectl status`. Make sure you can ping
all of them. Also verify that the DNS host name can be resolved against all/some of your DNS servers. Try the commands below:

```bash
$ host www.google.com
$ host www.google.com 8.8.8.8
$ dig www.google.com
$ resolvectl query www.google.com
```

### wireguard + Ubuntu 22.10

If you run `wg-quick up mywg` and suddenly DNS stops working (while it worked on Ubuntu 22.04),
the reason is that resolvectl is now configured a bit differently when wireguard conf file contains a DNS entry.

* On Ubuntu 22.04, any wireguard DNS entry would go into the `Global` section of `resolvectl status`, and
  your wireguard link's `Current Scopes` would read `none`
* On Ubuntu 22.10, the wireguard DNS entry goes into your wireguard link, sets the `Current Scopes` to `DNS` and adds `DNS Domain: ~.`
  which somehow breaks your DNS.

Workaround: comment out the DNS entry in your wireguard conf file.

## Local/mDNS/LLMNR

The `.local` top-level-domain (TLD) is reserved to be used for your LAN. Every machine
has its own hostname, and if configured properly, it is accessible on your LAN by
the name of `hostname.local`.

There are two competing standards, [mDNS/multicast DNS](https://en.wikipedia.org/wiki/Multicast_DNS)
and [LLMNR](https://en.wikipedia.org/wiki/Link-Local_Multicast_Name_Resolution); both use the same principle
of listening to broadcasts. Basically, when a computer needs to resolve `foo.local` to an IP address
it will perform a broadcast query on the LAN; the `foo` machine will then respond to the broadcast
with an answer which contains its IP address. mDNS is primarily used by Linux and Apple, LLMNR is used primarily by Windows.

mDNS performs lookup by broadcasting on UDP `224.0.0.251:5353`. All mDNS-capable server machines on LAN use `avahi-daemon` to listen
on UDP port 5353 and reply to the original sender with its IP address if the lookup targets that particular machine.

### mDNS Resolvers

In modern Linux desktops, you have multiple mDNS resolvers:

1. [nss-mdns](https://github.com/avahi/nss-mdns) plugs as GNU Name Service Switch (NSS) into `glibc`
   and resolves mDNS via `avahi-daemon` (see [StackExchange](https://superuser.com/questions/1453910/linux-command-to-get-mdns-service-discovery-and-to-get-its-ip-address)).
   You can test this resolver via `avahi-resolve --name foo.local`. All linux programs including `ping` and `ssh` uses this one.
2. `host`, `dig` and `resolvectl query` uses `systemd-resolved` to resolve mDNS.

Since ping uses `avahi-daemon`, it's possible that `ping` is able to resolve `foo.local` stuff while `host` and `resolvectl query` can't,
since they go through `systemd-resolved`.

### Enabling nss-mdns

Enabling this one is more important than systemd-resolved since all Linux programs except DNS clients such as `host` and `dig`
use this method.

See [nss-mdns: Activation](https://github.com/avahi/nss-mdns?tab=readme-ov-file#activation). In order to activate
this nss module you need to edit `/etc/nsswitch.conf` and make sure `mdns4` or `mdns4_minimal` are
included in the `hosts:` line. Also make sure `libnss-mdns` is installed: `sudo apt install libnss-mdns`.

### Enabling mDNS in systemd-resolved

If your `resolvectl query foo.local`/`host`/`dig` fails to resolve the local server, you may need to enable mDNS. First, run
`$ resolvectl status` and check whether mDNS is enabled. If not, see [ArchLinux Wiki on enabling mDNS](https://wiki.archlinux.org/title/Systemd-resolved#mDNS):

1. `sudo vim /etc/systemd/resolved.conf` and enable `MulticastDNS` in `[Resolve]`.
2. Restart systemd-resolved: `sudo systemctl restart systemd-resolved.service`

### mDNS from a virtual machine

The broadcast may not traverse more complex network setups which pretty much include VM networks. The right way
is to run the VM in the bridge networking mode. For example:

* Linux-on-Linux KVM with `virtio` and NAT: the guest can only resolve the host but not any other machine on the network.
  * Switching to bridged mode solved this. See [Virt Manager: Bridge](../virt-manager/) for more info.
* Linux-on-Mac UTM with `virtio-net-pci` and Shared Network: the same situation,
  the guest can only resolve the host but not any other machine on the network. See [UTM Network docs](https://docs.getutm.app/settings-qemu/devices/network/network/)
  for more details.
  * Switching to bridged mode solved this: it exposed the VM as if running on the LAN along with the host MacBook, and mDNS
    lookups started to pick up other machines on the LAN. The VM name was also resolvable from other LAN machines and was even pingable.

Another way could be NAT traversal but I have no idea whether mDNS can be configured that way.
