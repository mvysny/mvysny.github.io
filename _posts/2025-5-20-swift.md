---
layout: post
title: Swift Experiments
---

[Swift](https://www.swift.org/) looks really good - strong-typed,
the API makes sense, first-class support for native, and now you can develop in Linux
as well. The disadvantage is that the produced binaries depend on Swift being installed,
which means that you need to install Swift wherever you plan to run your binary.
This blog shows how to install and develop Swift on Ubuntu 25.04 aarch64.

# Installing stuff

To start with Ubuntu 25.04, simply install Swift via apt:
```bash
$ sudo apt install swiftlang binutils-gold
```

Then install IDEA, the community edition is enough:
```bash
$ sudo snap install intellij-idea-community
```
Afterwards, install the [Swift Support](https://plugins.jetbrains.com/plugin/22150-swift-support)
plugin by Joachim Ansong.

The plugin doesn't support navigating to certain classes (e.g. you can't
navigate to Foundation classes like String), but you can navigate to classes from your dependencies
and the autocompletion works quite well.

# Getting Started

You can follow the [Building a Command-line Tool](https://www.swift.org/getting-started/cli-swiftpm/)
tutorial to build and run a basic CLI app.

## Running

Open the terminal in Intellij and run `swift run`. You can also create a run configuration
in IDEA; a "Shell Script" works best:

* Execute: `Script text`
* Script text: `swift run`

Press `Ctrl+F10` to run the app.

## Troubleshooting

If you get this error while running `swift build` or `swift run`:
```
error: link command failed with exit code 1 (use -v to see invocation)
clang-15: error: invalid linker name in argument '-fuse-ld=gold'
```
Make sure `binutils-gold` is installed on your machine.

## Working with files

Reading a file is easy: `main.swift`:
```swift
import Foundation
print(try String(contentsOfFile: "foo.txt"))
print(try FileManager.default.contentsOfDirectory(atPath: "/home"))
```

# About the language

Swift have several features which make it remarkably close to Kotlin:
multi-line strings, strings with interpolation, types (`Int`, `UInt`, etc),
optional types (`Int?`).
The lack of GC is a bit of a bummer, but the reference counting hopefully makes
up for it, and reference counting makes more sense in embedded environments such as
phones, arm SOCs and Apple Watches.

I don't get the exception mechanism: all the `try`/`try?` stuff and you need
to add `throws` to all functions... Yes, stack unwinding is expensive but exceptions
are thrown sparingly in Kotlin program, so it's an acceptable penalty.

Do I like Swift much more than Go, C, C++, Dart? You bet. More than Kotlin/Native?
Probably yes - Kotlin/Native file support is barebones. More than Kotlin/JVM? Nope.
